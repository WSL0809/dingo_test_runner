# 移植 golang 版本的 mysql-test-runner 到 Rust 版本
# MySQL Tester Go ➜ Rust 迁移计划

> 本文档描述将现有 Go 版本 `mysql-tester` 迁移至 **Rust（同步实现）** 的整体方案、阶段目标与关键技术决策，以指导后续开发工作。

---

## 1. 项目目标
1. **功能等价**：Rust 版本在 CLI 参数、测试框架语义、日志输出、结果文件（`r/`）、JUnit XML 报告等方面与目前 Go 版保持一致。
2. **同步实现**：采用同步 MySQL 驱动（不引入 Tokio/async），多线程负责并发测试执行。
3. **性能不降**：在高并发测试用例下，整体运行时间不劣于 Go 版。
4. **可维护性**：充分利用 Rust 类型系统与错误传播，提高代码安全性与可读性。
5. **交付产物**：生成单一可执行文件 `mysql-tester`，支持 macOS / Linux。

## 2. 技术选型
| 需求 | 选型 | 说明 |
|------|------|------|
| MySQL 驱动 | `mysql` crate (v24+) | 同步 API，支持连接池 `mysql::Pool` |
| CLI 解析 | `clap` v4 | 与 Go `flag` 语义对应，保留参数名兼容 |
| 日志 | `log` + `env_logger` | 输出格式接近 logrus，透过 `RUST_LOG` 控制等级 |
| XML 生成 | `quick-xml` + `serde-xml-rs` | 生成 JUnit/XUnit 报告 |
| 并发 | `rayon` 线程池或 `threadpool` + `crossbeam` | 覆盖 `BEGIN_CONCURRENT` 等场景 |
| 错误处理 | `anyhow` + `thiserror` | 统一错误栈追踪 |
| 邮件功能 | 暂缓 | 保留模块桩，后续接入 `lettre` |

## 3. 阶段性任务

### Phase 0 – 仓库初始化
- 建立 Cargo 项目 & `rust-toolchain.toml`。
- 配置 CI（fmt、clippy、unit-test）。
- 实现 CLI skeleton（解析常用 flag，但尚未执行业务逻辑）。

### Phase 1 – 解析层
- 枚举 `QueryType`、静态 `COMMAND_MAP`。
- 结构体 `Query`、方法 `parse()`，解析规则需完全兼容原 Go 实现（`--`、`#`、delimiter 等）。
- 单元测试：读取典型 `.test` 文件，比对解析结果。

### Phase 2 – 数据库与连接管理
- 封装 `Conn`：持有 `mysql::Conn` 及连接信息；实现 `init_conn` 行为（切库等）。
- `open_db_with_retry()`：指数退避重连，输出友好提示。
- `Tester`：初版实现 `pre_process()`/`post_process()`，完成数据库创建与清理。

### Phase 3 – 执行引擎（串行） (✅ 已完成)
- 迁移 `execute`, `stmt_execute`, `write_query_result`。
- 支持 `record` / 比对模式（读写 `r/` 目录文件）。
- 完成 `--sorted_result`、`--replace_regex`、日志开关等关键指令。
- 错误码映射：处理 `mysql::error::Error::Server`。

### Phase 4 – 关键指令支持 (`--replace_regex` & 连接管理) (✅ 已完成)
- 实现 `--replace_regex` 指令，允许使用正则表达式替换输出结果。
- 实现连接管理系列指令：
  - `--connect(conn_name, host, user, password, db)`: 创建并切换到一个新连接。
  - `--disconnect(conn_name)`:断开指定连接。
  - `--connection(conn_name)`: 切换到已存在的连接。
- `Tester` 内部需维护一个连接池或 `HashMap` 来管理多个具名连接。

### Phase 5 – 并发支持（多线程）
- 使用 Rayon 或手动线程池实现 `BEGIN_CONCURRENT / END_CONCURRENT` 队列。
- `crossbeam::channel` 替代 Go 的 `msgs`，聚合任务结果。
- 线程间共享写缓冲需 `Arc<Mutex<...>>` 保护。

### Phase 6 – 批量调度 & 结果汇总
- 迁移 `load_all_tests`、`convert_tests_to_test_tasks`、`execute_tests` 逻辑。
- 汇总错误、生成 `TestResult` 与 `TestCaseResult` 结构体。

### Phase 7 – 功能补齐
- 已完成 `sorted_result`、`replace_regex`。
- 待完成 `replace_column`、WARN/INFO 开关等剩余指令。
- 保留 `email` stub，确保编译通过但无实际发送行为。

### Phase 8 – JUnit/XUnit 报告
- 依据结构体序列化生成 XML 文件；支持 `-xunitfile` flag。

### Phase 9 – 对照测试 & 性能评估
- 在同一数据库环境运行 Go 与 Rust 版本，对比输出字节级一致。
- benchmark 大型 case（如 `sub_query_more`、`role`）。
- 调整线程池大小、连接池配置。

### Phase 10 – 文档与发布
- 更新 README、示例命令行。
- GitHub Actions 打包 macOS / Linux release artifacts。

## 4. 目录结构示例
```
mysql-tester-rs/
├─ Cargo.toml
├─ src/
│  ├─ main.rs          # CLI 入口
│  ├─ cli.rs           # 参数解析
│  ├─ tester/          # 核心逻辑
│  │   ├─ mod.rs
│  │   ├─ tester.rs
│  │   ├─ conn.rs
│  │   ├─ query.rs
│  │   └─ parser.rs
│  ├─ util/
│  │   ├─ mod.rs
│  │   └─ regex.rs
│  ├─ report/
│  │   └─ xunit.rs
│  └─ stub/
│      └─ email.rs     # 未来接入邮件通知
└─ tests/              # Rust 集成测试
```

## 5. 注意事项
1. **NULL vs 空串**：Rust 采用 `Option<Vec<u8>>` 区分，排序逻辑需复制 Go 版特殊规则。
2. **线程安全**：记录缓冲、错误聚合等需加锁；DB 连接应按线程独占或从池获取，避免死锁。
3. **日志输出**：保持 `env_logger` 行为与 logrus 近似，支持 `RUST_LOG=debug`。
4. **兼容 CLI**：使用 `clap` 的 `alias`，确保旧脚本无痛切换。

---

> 以上即为 Rust 迁移的详细计划。如需调整或补充，请在评论中提出。 

# 原版主要 go 代码
//main.go
// Copyright 2020 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"context"
	"database/sql"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/defined2014/mysql"
	"github.com/pingcap/errors"
	log "github.com/sirupsen/logrus"
)

var (
	host             string
	port             string
	user             string
	passwd           string
	logLevel         string
	record           bool
	params           string
	all              bool
	reserveSchema    bool
	xmlPath          string
	retryConnCount   int
	collationDisable bool
	checkErr         bool
	extension        string
	// 邮件相关配置参数
	emailEnable    bool
	emailSMTPHost  string
	emailSMTPPort  int
	emailUsername  string
	emailPassword  string
	emailFrom      string
	emailTo        string
	emailEnableTLS bool
)

func init() {
	flag.StringVar(&host, "host", "127.0.0.1", "The host of the TiDB/MySQL server.")
	flag.StringVar(&port, "port", "3306", "The listen port of TiDB/MySQL server.")
	flag.StringVar(&user, "user", "root", "The user for connecting to the database.")
	flag.StringVar(&passwd, "passwd", "", "The password for the user.")
	flag.StringVar(&logLevel, "log-level", "error", "The log level of mysql-tester: info, warn, error, debug.")
	flag.BoolVar(&record, "record", false, "Whether to record the test output to the result file.")
	flag.StringVar(&params, "params", "", "Additional params pass as DSN(e.g. session variable)")
	flag.BoolVar(&all, "all", false, "run all tests")
	flag.BoolVar(&reserveSchema, "reserve-schema", false, "Reserve schema after each test")
	flag.StringVar(&xmlPath, "xunitfile", "", "The xml file path to record testing results.")
	flag.IntVar(&retryConnCount, "retry-connection-count", 120, "The max number to retry to connect to the database.")
	flag.BoolVar(&checkErr, "check-error", false, "if --error ERR does not match, return error instead of just warn")
	flag.BoolVar(&collationDisable, "collation-disable", false, "run collation related-test with new-collation disabled")
	flag.StringVar(&extension, "extension", "result", "the result file extension for result file")
	// 邮件相关参数
	flag.BoolVar(&emailEnable, "email-enable", false, "enable email notification for test results")
	flag.StringVar(&emailSMTPHost, "email-smtp-host", "", "SMTP server host for email notification")
	flag.IntVar(&emailSMTPPort, "email-smtp-port", 587, "SMTP server port for email notification")
	flag.StringVar(&emailUsername, "email-username", "", "email username for SMTP authentication")
	flag.StringVar(&emailPassword, "email-password", "", "email password or app password for SMTP authentication")
	flag.StringVar(&emailFrom, "email-from", "MySQL Tester", "sender name for email notification")
	flag.StringVar(&emailTo, "email-to", "", "recipient email addresses (comma separated)")
	flag.BoolVar(&emailEnableTLS, "email-enable-tls", true, "enable TLS for SMTP connection")
}

const (
	default_connection = "default"
)

type query struct {
	firstWord string
	Query     string
	delimiter string
	Line      int
	tp        int
}

type Conn struct {
	// DB might be a shared one by multiple Conn, if the connection information are the same.
	mdb *sql.DB
	// connection information.
	hostName string
	userName string
	password string
	db       string
	port     string

	conn *sql.Conn
}

type ReplaceColumn struct {
	col     int
	replace []byte
}

type ReplaceRegex struct {
	regex   *regexp.Regexp
	replace string
}

type tester struct {
	mdb  *sql.DB
	name string

	originalSchemas map[string]struct{}

	curr *Conn

	buf bytes.Buffer

	// enable query log will output origin statement into result file too
	// use --disable_query_log or --enable_query_log to control it
	enableQueryLog bool

	// enable result log will output to result file or not.
	// use --enable_result_log or --disable_result_log to control it
	enableResultLog bool

	// sortedResult make the output or the current query sorted.
	sortedResult bool

	enableConcurrent bool

	// Disable or enable warnings. This setting is enabled by default.
	// With this setting enabled, mysqltest uses SHOW WARNINGS to display
	// any warnings produced by SQL statements.
	enableWarning bool

	// enable query info, like rowsAffected, lastMessage etc.
	enableInfo bool

	// check expected error, use --error before the statement
	// see http://dev.mysql.com/doc/mysqltest/2.0/en/writing-tests-expecting-errors.html
	expectedErrs []string

	// only for test, not record, every time we execute a statement, we should read the result
	// data to check correction.
	resultFD *os.File

	// conns record connection created by test.
	conn map[string]*Conn

	// currConnName record current connection name.
	currConnName string

	// replace output column through --replace_column 1 <static data> 3 #
	replaceColumn []ReplaceColumn

	// replace output result through --replace_regex /\.dll/.so/
	replaceRegex []*ReplaceRegex

	// the delimter for TiDB, default value is ";"
	delimiter string
}

func newTester(name string) *tester {
	t := new(tester)

	t.name = name
	t.enableQueryLog = true
	t.enableResultLog = true
	// disable warning by default since our a lot of test cases
	// are ported wihtout explictly "disablewarning"
	t.enableWarning = false
	t.enableConcurrent = false
	t.enableInfo = false
	t.delimiter = ";"

	return t
}

func (t *tester) addConnection(connName, hostName, userName, password, db, connPort string) {
	var (
		mdb *sql.DB
		err error
	)

	if t.expectedErrs == nil {
		if t.curr != nil &&
			t.curr.hostName == hostName &&
			t.curr.userName == userName &&
			t.curr.password == password &&
			t.curr.port == connPort &&
			t.curr.db == db &&
			t.expectedErrs == nil {
			// Reuse mdb
			mdb = t.curr.mdb
		} else {
			mdb, err = OpenDBWithRetry("mysql", userName+":"+password+"@tcp("+hostName+":"+connPort+")/"+db+"?time_zone=%27Asia%2FShanghai%27&allowAllFiles=true"+params, retryConnCount)
		}
	} else {
		mdb, err = OpenDBWithRetry("mysql", userName+":"+password+"@tcp("+hostName+":"+connPort+")/"+db+"?time_zone=%27Asia%2FShanghai%27&allowAllFiles=true"+params, 1)
	}
	if err != nil {
		if t.expectedErrs == nil {
			log.Fatalf("无法连接到数据库 [%s:%s]，请检查数据库配置。错误详情：%v", hostName, connPort, err)
		}
		t.expectedErrs = nil
		return
	}
	conn, err := initConn(mdb, hostName, userName, password, db, connPort)
	if err != nil {
		if t.expectedErrs == nil {
			log.Fatalf("数据库连接初始化失败 [%s:%s]，可能是权限问题或数据库不存在。错误详情：%v", hostName, connPort, err)
		}
		t.expectedErrs = nil
		return
	}
	t.conn[connName] = conn
	t.switchConnection(connName)
}

func (t *tester) switchConnection(connName string) {
	conn, ok := t.conn[connName]
	if !ok {
		log.Fatalf("Connection %v doesn't exist.", connName)
	}
	// switch connection.
	t.mdb = conn.mdb
	t.curr = conn
	t.currConnName = connName
}

func (t *tester) disconnect(connName string) {
	conn, ok := t.conn[connName]
	if !ok {
		log.Fatalf("Connection %v doesn't exist.", connName)
	}
	err := conn.conn.Close()
	if err != nil {
		log.Fatal(err)
	}
	delete(t.conn, connName)
	conn = t.conn[default_connection]
	t.curr = conn
	t.mdb = conn.mdb
	t.currConnName = default_connection
}

func (t *tester) preProcess() {
	// 首先连接到一个已知存在的数据库来进行初始化操作
	initialDbName := "mysql" // 使用 mysql 系统数据库进行初始化
	mdb, err := OpenDBWithRetry("mysql", user+":"+passwd+"@tcp("+host+":"+port+")/"+initialDbName+"?time_zone=%27Asia%2FShanghai%27&allowAllFiles=true"+params, retryConnCount)
	t.conn = make(map[string]*Conn)
	if err != nil {
		log.Fatalf("测试环境初始化失败，无法连接到数据库 [%s:%s]。错误详情：%v", host, port, err)
	}

	if !reserveSchema {
		// store original schemas
		t.originalSchemas = make(map[string]struct{})
		rows, err := mdb.Query("show databases")
		if err != nil {
			log.Errorf("failed to get databases: %s", err.Error())
			return
		}
		var existingDbName string
		for rows.Next() {
			rows.Scan(&existingDbName)
			t.originalSchemas[existingDbName] = struct{}{}
		}
	}

	// 创建测试专用数据库
	testDbName := strings.ReplaceAll(t.name, "/", "__")
	log.Debugf("Create new db `%s`", testDbName)
	if _, err = mdb.Exec(fmt.Sprintf("create database `%s`", testDbName)); err != nil {
		log.Fatalf("创建测试数据库失败 [数据库名: %s]，可能是权限不足或数据库已存在。错误详情：%v", testDbName, err)
	}

	// 关闭初始连接
	mdb.Close()

	// 重新连接到测试数据库
	testMdb, err := OpenDBWithRetry("mysql", user+":"+passwd+"@tcp("+host+":"+port+")/"+testDbName+"?time_zone=%27Asia%2FShanghai%27&allowAllFiles=true"+params, retryConnCount)
	if err != nil {
		log.Fatalf("连接到测试数据库失败 [%s:%s/%s]。错误详情：%v", host, port, testDbName, err)
	}

	t.mdb = testMdb
	conn, err := initConn(testMdb, host, user, passwd, testDbName, port)
	if err != nil {
		log.Fatalf("测试数据库初始化失败 [%s:%s/%s]，可能是权限不足或数据库创建失败。错误详情：%v", host, port, testDbName, err)
	}
	t.conn[default_connection] = conn
	t.curr = conn
	t.currConnName = default_connection
}

func (t *tester) postProcess() {
	mdbMap := make(map[*sql.DB]struct{})
	for _, v := range t.conn {
		v.conn.Close()
		mdbMap[v.mdb] = struct{}{}
	}
	for mdb := range mdbMap {
		if mdb != nil {
			mdb.Close()
		}
	}

	if !reserveSchema {
		mdb, err := OpenDBWithRetry("mysql", user+":"+passwd+"@tcp("+host+":"+port+")/mysql?time_zone=%27Asia%2FShanghai%27&allowAllFiles=true"+params, retryConnCount)
		if err != nil {
			log.Errorf("failed to connect to mysql for cleanup: %v", err)
			return
		}
		defer mdb.Close()

		rows, err := mdb.Query("show databases")
		if err != nil {
			log.Errorf("failed to get databases: %s", err.Error())
			return
		}
		var dbName string
		for rows.Next() {
			rows.Scan(&dbName)
			if _, exists := t.originalSchemas[dbName]; !exists {
				// 先尝试删除数据库中的所有表
				tableRows, err := mdb.Query(fmt.Sprintf("SELECT table_name FROM information_schema.tables WHERE table_schema = '%s'", dbName))
				if err == nil {
					var tableName string
					var tables []string
					for tableRows.Next() {
						tableRows.Scan(&tableName)
						tables = append(tables, tableName)
					}
					tableRows.Close()

					// 删除所有表
					for _, table := range tables {
						_, err := mdb.Exec(fmt.Sprintf("DROP TABLE IF EXISTS `%s`.`%s`", dbName, table))
						if err != nil {
							log.Debugf("failed to drop table %s.%s: %s", dbName, table, err.Error())
						}
					}
				}

				// 现在尝试删除数据库
				_, err = mdb.Exec(fmt.Sprintf("DROP DATABASE IF EXISTS `%s`", dbName))
				if err != nil {
					log.Errorf("failed to drop database %s: %s", dbName, err.Error())
				} else {
					log.Debugf("successfully dropped database %s", dbName)
				}
			}
		}
	}
}

func (t *tester) addFailure(testSuite *XUnitTestSuite, err *error, cnt int) {
	testSuite.TestCases = append(testSuite.TestCases, XUnitTestCase{
		Classname:  "",
		Name:       t.testFileName(),
		Time:       "",
		QueryCount: cnt,
		Status:     "failed",
		Failure: &XUnitFailure{
			Message: "Test failed",
			Type:    "AssertionError",
			Content: (*err).Error(),
		},
	})
	testSuite.Failures++
}

func (t *tester) addSuccess(testSuite *XUnitTestSuite, startTime *time.Time, cnt int) {
	testSuite.TestCases = append(testSuite.TestCases, XUnitTestCase{
		Classname:  "",
		Name:       t.testFileName(),
		Time:       fmt.Sprintf("%fs", time.Since(*startTime).Seconds()),
		Status:     "passed",
		QueryCount: cnt,
	})
}

func (t *tester) Run() error {
	t.preProcess()
	defer t.postProcess()
	queries, err := t.loadQueries()
	if err != nil {
		err = errors.Trace(err)
		t.addFailure(&testSuite, &err, 0)
		return err
	}

	if err = t.openResult(); err != nil {
		err = errors.Trace(err)
		t.addFailure(&testSuite, &err, 0)
		return err
	}

	var s string
	defer func() {
		if t.resultFD != nil {
			t.resultFD.Close()
		}
	}()

	testCnt := 0
	startTime := time.Now()
	var concurrentQueue []query
	var concurrentSize int
	for _, q := range queries {
		s = q.Query
		switch q.tp {
		case Q_ENABLE_QUERY_LOG:
			t.enableQueryLog = true
		case Q_DISABLE_QUERY_LOG:
			t.enableQueryLog = false
		case Q_ENABLE_RESULT_LOG:
			t.enableResultLog = true
		case Q_DISABLE_RESULT_LOG:
			t.enableResultLog = false
		case Q_DISABLE_WARNINGS:
			t.enableWarning = false
		case Q_ENABLE_WARNINGS:
			t.enableWarning = true
		case Q_ENABLE_INFO:
			t.enableInfo = true
		case Q_DISABLE_INFO:
			t.enableInfo = false
		case Q_BEGIN_CONCURRENT:
			// mysql-tester enhancement
			concurrentQueue = make([]query, 0)
			t.enableConcurrent = true
			if s == "" {
				concurrentSize = 8
			} else {
				concurrentSize, err = strconv.Atoi(strings.TrimSpace(s))
				if err != nil {
					err = errors.Annotate(err, "Atoi failed")
					t.addFailure(&testSuite, &err, testCnt)
					return err
				}
			}
		case Q_END_CONCURRENT:
			t.enableConcurrent = false
			if err = t.concurrentRun(concurrentQueue, concurrentSize); err != nil {
				err = errors.Annotate(err, fmt.Sprintf("concurrent test failed in %v", t.name))
				t.addFailure(&testSuite, &err, testCnt)
				return err
			}
			t.expectedErrs = nil
		case Q_ERROR:
			t.expectedErrs = strings.Split(strings.TrimSpace(s), ",")
		case Q_ECHO:
			varSearch := regexp.MustCompile(`\$([A-Za-z0-9_]+)( |$)`)
			s := varSearch.ReplaceAllStringFunc(s, func(s string) string {
				return os.Getenv(varSearch.FindStringSubmatch(s)[1])
			})

			t.buf.WriteString(s)
			t.buf.WriteString("\n")
		case Q_QUERY:
			if t.enableConcurrent {
				concurrentQueue = append(concurrentQueue, q)
			} else if err = t.execute(q); err != nil {
				err = errors.Annotate(err, fmt.Sprintf("sql:%v", q.Query))
				t.addFailure(&testSuite, &err, testCnt)
				return err
			}

			testCnt++

			t.sortedResult = false
			t.replaceColumn = nil
			t.replaceRegex = nil
		case Q_SORTED_RESULT:
			t.sortedResult = true
		case Q_REPLACE_COLUMN:
			// TODO: Use CSV module or so to handle quoted replacements
			t.replaceColumn = nil // Only use the latest one!
			cols := strings.Fields(q.Query)
			// Require that col + replacement comes in pairs otherwise skip the last column number
			for i := 0; i < len(cols)-1; i = i + 2 {
				colNr, err := strconv.Atoi(cols[i])
				if err != nil {
					err = errors.Annotate(err, fmt.Sprintf("Could not parse column in --replace_column: sql:%v", q.Query))
					t.addFailure(&testSuite, &err, testCnt)
					return err
				}

				t.replaceColumn = append(t.replaceColumn, ReplaceColumn{col: colNr, replace: []byte(cols[i+1])})
			}
		case Q_CONNECT:
			q.Query = strings.TrimSuffix(strings.TrimSpace(q.Query), q.delimiter)
			q.Query = q.Query[1 : len(q.Query)-1]
			args := strings.Split(q.Query, ",")
			for i := range args {
				args[i] = strings.TrimSpace(args[i])
			}
			for len(args) < 6 {
				args = append(args, "")
			}

			connName := args[0]
			hostName := args[1]
			userName := args[2]
			passwordInConnect := args[3]
			dbName := args[4]
			portInConnect := args[5]

			if hostName == "" {
				hostName = host
			}
			if userName == "" {
				userName = user
			}
			if passwordInConnect == "" {
				passwordInConnect = passwd
			}
			if portInConnect == "" {
				portInConnect = port
			}
			t.addConnection(connName, hostName, userName, passwordInConnect, dbName, portInConnect)
		case Q_CONNECTION:
			q.Query = strings.TrimSuffix(strings.TrimSpace(q.Query), q.delimiter)
			t.switchConnection(q.Query)
		case Q_DISCONNECT:
			q.Query = strings.TrimSuffix(strings.TrimSpace(q.Query), q.delimiter)
			t.disconnect(q.Query)
		case Q_LET:
			q.Query = strings.TrimSpace(q.Query)
			eqIdx := strings.Index(q.Query, "=")
			if eqIdx > 1 {
				start := 0
				if q.Query[0] == '$' {
					start = 1
				}
				varName := strings.TrimSpace(q.Query[start:eqIdx])
				varValue := strings.TrimSpace(q.Query[eqIdx+1:])
				varSearch := regexp.MustCompile("`(.*)`")
				varValue = varSearch.ReplaceAllStringFunc(varValue, func(s string) string {
					s = strings.Trim(s, "`")
					r, err := t.executeStmtString(s)
					if err != nil {
						log.WithFields(log.Fields{
							"query": s, "line": q.Line},
						).Error("failed to perform let query")
						return ""
					}
					return r
				})
				os.Setenv(varName, varValue)
			}
		case Q_REMOVE_FILE:
			err = os.Remove(strings.TrimSpace(q.Query))
			if err != nil {
				return errors.Annotate(err, "failed to remove file")
			}
		case Q_REPLACE_REGEX:
			t.replaceRegex = nil
			regex, err := ParseReplaceRegex(q.Query)
			if err != nil {
				return errors.Annotate(err, fmt.Sprintf("Could not parse regex in --replace_regex: line: %d sql:%v", q.Line, q.Query))
			}
			t.replaceRegex = regex
		default:
			log.WithFields(log.Fields{"command": q.firstWord, "arguments": q.Query, "line": q.Line}).Warn("command not implemented")
		}
	}

	// check do we have remained lines in result file
	buf := make([]byte, 32)
	if n, _ := t.resultFD.ReadAt(buf, int64(t.buf.Len())); n != 0 {
		return errors.Trace(errors.Errorf("There is extra data at the end of the result file: %s", buf))
	}

	fmt.Printf("%s: ok! %d test cases passed, take time %v s\n", t.testFileName(), testCnt, time.Since(startTime).Seconds())

	if xmlPath != "" {
		t.addSuccess(&testSuite, &startTime, testCnt)
	}

	return t.flushResult()
}

func (t *tester) concurrentRun(concurrentQueue []query, concurrentSize int) error {
	if len(concurrentQueue) == 0 {
		return nil
	}
	offset := t.buf.Len()

	if concurrentSize <= 0 {
		return errors.Errorf("concurrentSize must be positive")
	}
	if concurrentSize > len(concurrentQueue) {
		concurrentSize = len(concurrentQueue)
	}
	batchQuery := make([][]query, concurrentSize)
	for i, query := range concurrentQueue {
		j := i % concurrentSize
		batchQuery[j] = append(batchQuery[j], query)
	}
	errOccured := make(chan struct{}, len(concurrentQueue))
	var wg sync.WaitGroup
	wg.Add(len(batchQuery))
	for _, q := range batchQuery {
		go t.concurrentExecute(q, &wg, errOccured)
	}
	wg.Wait()
	close(errOccured)
	if _, ok := <-errOccured; ok {
		return errors.Errorf("Run failed")
	}
	buf := t.buf.Bytes()[:offset]
	t.buf = *(bytes.NewBuffer(buf))
	return nil
}

func initConn(mdb *sql.DB, host, user, passwd, dbName, connPort string) (*Conn, error) {
	mdb.SetMaxIdleConns(-1) // Disable the underlying connection pool.
	sqlConn, err := mdb.Conn(context.Background())
	if err != nil {
		return nil, err
	}
	conn := &Conn{
		mdb:      mdb,
		hostName: host,
		userName: user,
		password: passwd,
		db:       dbName,
		port:     connPort,
		conn:     sqlConn,
	}
	if dbName != "" {
		if _, err = sqlConn.ExecContext(context.Background(), fmt.Sprintf("use `%s`", dbName)); err != nil {
			log.Fatalf("切换到数据库失败 [数据库名: %s]，可能是数据库不存在或权限不足。错误详情：%v", dbName, err)
		}
	}
	return conn, nil
}

func (t *tester) concurrentExecute(querys []query, wg *sync.WaitGroup, errOccured chan struct{}) {
	defer wg.Done()
	tt := newTester(t.name)
	testDbName := strings.ReplaceAll(t.name, "/", "__")
	mdb, err := OpenDBWithRetry("mysql", user+":"+passwd+"@tcp("+host+":"+port+")/"+testDbName+"?time_zone=%27Asia%2FShanghai%27&allowAllFiles=true"+params, retryConnCount)
	if err != nil {
		log.Fatalf("并发测试环境初始化失败，无法连接到数据库 [%s:%s]。错误详情：%v", host, port, err)
	}
	conn, err := initConn(mdb, host, user, passwd, testDbName, port)
	if err != nil {
		log.Fatalf("并发测试数据库初始化失败 [%s:%s/%s]，可能是权限不足。错误详情：%v", host, port, testDbName, err)
	}
	tt.curr = conn
	tt.mdb = mdb
	defer tt.mdb.Close()

	for _, query := range querys {
		if len(query.Query) == 0 {
			return
		}

		err := tt.stmtExecute(query)
		if err != nil && len(t.expectedErrs) > 0 {
			for _, tStr := range t.expectedErrs {
				if strings.Contains(err.Error(), tStr) {
					err = nil
					break
				}
			}
		}
		if err != nil {
			msgs <- testTask{
				test: t.name,
				err:  errors.Trace(errors.Errorf("run \"%v\" at line %d err %v", query.Query, query.Line, err)),
			}
			errOccured <- struct{}{}
			return
		}
	}
}

func (t *tester) loadQueries() ([]query, error) {
	data, err := os.ReadFile(t.testFileName())
	if err != nil {
		return nil, err
	}

	seps := bytes.Split(data, []byte("\n"))
	queries := make([]query, 0, len(seps))
	buffer := ""
	for i, v := range seps {
		v := bytes.TrimSpace(v)
		s := string(v)
		// we will skip # comment here
		if strings.HasPrefix(s, "#") {
			if len(buffer) != 0 {
				return nil, errors.Errorf("Has remained message(%s) before COMMENTS", buffer)
			}
			continue
		} else if strings.HasPrefix(s, "--") {
			if len(buffer) != 0 {
				return nil, errors.Errorf("Has remained message(%s) before COMMANDS", buffer)
			}
			q, err := ParseQuery(query{Query: s, Line: i + 1, delimiter: t.delimiter})
			if err != nil {
				return nil, err
			}
			if q == nil {
				continue
			}
			if q.tp == Q_DELIMITER {
				tokens := strings.Split(strings.TrimSpace(q.Query), " ")
				if len(tokens) == 0 {
					return nil, errors.Errorf("DELIMITER must be followed by a 'delimiter' character or string")
				}
				t.delimiter = tokens[0]
			} else {
				queries = append(queries, *q)
			}
			continue
		} else if strings.HasPrefix(strings.ToLower(strings.TrimSpace(s)), "delimiter ") {
			if len(buffer) != 0 {
				return nil, errors.Errorf("Has remained message(%s) before DELIMITER COMMAND", buffer)
			}
			tokens := strings.Split(strings.TrimSpace(s), " ")
			if len(tokens) <= 1 {
				return nil, errors.Errorf("DELIMITER must be followed by a 'delimiter' character or string")
			}
			t.delimiter = tokens[1]
			continue
		} else if len(s) == 0 {
			continue
		}

		if len(buffer) != 0 {
			buffer += "\n"
		}
		buffer += s
		for {
			idx := strings.LastIndex(buffer, t.delimiter)
			if idx == -1 {
				break
			}

			queryStr := buffer[:idx+len(t.delimiter)]
			buffer = buffer[idx+len(t.delimiter):]
			q, err := ParseQuery(query{Query: strings.TrimSpace(queryStr), Line: i + 1, delimiter: t.delimiter})
			if err != nil {
				return nil, err
			}
			if q == nil {
				continue
			}
			queries = append(queries, *q)
		}
		// If has remained comments, ignore them.
		if len(buffer) != 0 && strings.HasPrefix(strings.TrimSpace(buffer), "#") {
			buffer = ""
		}
	}
	if len(buffer) != 0 {
		return nil, errors.Errorf("Has remained text(%s) in file", buffer)
	}
	return queries, nil
}

func (t *tester) stmtExecute(query query) (err error) {
	if t.enableQueryLog {
		t.buf.WriteString(query.Query)
		t.buf.WriteString("\n")
	}

	return t.executeStmt(strings.TrimSuffix(query.Query, query.delimiter))
}

// checkExpectedError check if error was expected
// If so, it will handle Buf and return nil
func (t *tester) checkExpectedError(q query, err error) error {
	if err == nil {
		if len(t.expectedErrs) == 0 {
			return nil
		}
		for _, s := range t.expectedErrs {
			s = strings.TrimSpace(s)
			if s == "0" {
				// 0 means accept any error!
				return nil
			}
		}
		if !checkErr {
			log.Warnf("%s:%d query succeeded, but expected error(s)! (expected errors: %s) (query: %s)",
				t.name, q.Line, strings.Join(t.expectedErrs, ","), q.Query)
			return nil
		}
		return errors.Errorf("Statement succeeded, expected error(s) '%s'", strings.Join(t.expectedErrs, ","))
	}
	if len(t.expectedErrs) == 0 {
		return err
	}
	// Parse the error to get the mysql error code
	errNo := 0
	switch innerErr := errors.Cause(err).(type) {
	case *mysql.MySQLError:
		errNo = int(innerErr.Number)
	}
	if errNo == 0 {
		log.Warnf("%s:%d Could not parse mysql error: %s", t.name, q.Line, err.Error())
		return err
	}
	for _, s := range t.expectedErrs {
		s = strings.TrimSpace(s)
		checkErrNo, err1 := strconv.Atoi(s)
		if err1 != nil {
			i, ok := MysqlErrNameToNum[s]
			if ok {
				checkErrNo = i
			} else {
				if len(t.expectedErrs) > 1 {
					log.Warnf("%s:%d Unknown named error %s in --error %s", t.name, q.Line, s, strings.Join(t.expectedErrs, ","))
				} else {
					log.Warnf("%s:%d Unknown named --error %s", t.name, q.Line, s)
				}
				continue
			}
		}
		if errNo == checkErrNo {
			if len(t.expectedErrs) == 1 || !checkErr {
				// !checkErr - Also keep old behavior, i.e. not use "Got one of the listed errors"
				errStr := err.Error()
				for _, reg := range t.replaceRegex {
					errStr = reg.regex.ReplaceAllString(errStr, reg.replace)
				}
				fmt.Fprintf(&t.buf, "%s\n", strings.ReplaceAll(errStr, "\r", ""))
			} else if strings.TrimSpace(t.expectedErrs[0]) != "0" {
				fmt.Fprintf(&t.buf, "Got one of the listed errors\n")
			}
			return nil
		}
	}
	if !checkErr {
		gotErrCode := strconv.Itoa(errNo)
		for k, v := range MysqlErrNameToNum {
			if v == errNo {
				gotErrCode = k
				break
			}
		}
		if len(t.expectedErrs) > 1 {
			log.Warnf("%s:%d query failed with non expected error(s)! (%s not in %s) (err: %s) (query: %s)",
				t.name, q.Line, gotErrCode, strings.Join(t.expectedErrs, ","), err.Error(), q.Query)
		} else {
			log.Warnf("%s:%d query failed with non expected error(s)! (%s != %s) (err: %s) (query: %s)",
				t.name, q.Line, gotErrCode, t.expectedErrs[0], err.Error(), q.Query)
		}
		errStr := err.Error()
		for _, reg := range t.replaceRegex {
			errStr = reg.regex.ReplaceAllString(errStr, reg.replace)
		}
		fmt.Fprintf(&t.buf, "%s\n", strings.ReplaceAll(errStr, "\r", ""))
		return nil
	}
	return err
}

func (t *tester) execute(query query) error {
	if len(query.Query) == 0 {
		return nil
	}

	offset := t.buf.Len()
	err := t.stmtExecute(query)

	err = t.checkExpectedError(query, err)
	if err != nil {
		return errors.Trace(errors.Errorf("run \"%v\" at line %d err %v", query.Query, query.Line, err))
	}

	// clear expected errors after we execute the first query
	t.expectedErrs = nil

	if !record {
		// check test result now
		gotBuf := t.buf.Bytes()[offset:]

		buf := make([]byte, t.buf.Len()-offset)
		if _, err = t.resultFD.ReadAt(buf, int64(offset)); err != nil {
			return errors.Trace(errors.Errorf("run \"%v\" at line %d err, we got \n%s\nbut read result err %s", query.Query, query.Line, gotBuf, err))
		}

		if !bytes.Equal(gotBuf, buf) {
			return errors.Trace(errors.Errorf("failed to run query \n\"%v\" \n around line %d, \nwe need(%v):\n%s\nbut got(%v):\n%s\n", query.Query, query.Line, len(buf), buf, len(gotBuf), gotBuf))
		}
	}

	return errors.Trace(err)
}

func (t *tester) writeQueryResult(rows *byteRows) error {
	if t.sortedResult {
		sort.Sort(rows)
	}

	if len(t.replaceColumn) > 0 {
		for _, row := range rows.data {
			for _, r := range t.replaceColumn {
				if len(row.data) < r.col {
					continue
				}
				row.data[r.col-1] = r.replace
			}
		}
	}

	cols := rows.cols
	for i, c := range cols {
		t.buf.WriteString(c)
		if i != len(cols)-1 {
			t.buf.WriteString("\t")
		}
	}
	t.buf.WriteString("\n")

	for _, row := range rows.data {
		var value string
		for i, col := range row.data {
			// replace result by regex
			for _, reg := range t.replaceRegex {
				col = reg.regex.ReplaceAll(col, []byte(reg.replace))
			}

			// Here we can check if the value is nil (NULL value)
			if col == nil {
				value = "NULL"
			} else {
				value = string(col)
			}
			t.buf.WriteString(value)
			if i < len(row.data)-1 {
				t.buf.WriteString("\t")
			}
		}
		t.buf.WriteString("\n")
	}
	return nil
}

type byteRow struct {
	data [][]byte
}

type byteRows struct {
	cols []string
	data []byteRow
}

func (rows *byteRows) Len() int {
	return len(rows.data)
}

func (rows *byteRows) Less(i, j int) bool {
	r1 := rows.data[i]
	r2 := rows.data[j]
	for i := 0; i < len(r1.data); i++ {
		res := bytes.Compare(r1.data[i], r2.data[i])
		switch res {
		case -1:
			return true
		case 1:
			return false
		case 0:
			// bytes.Compare(nil, []byte{}) returns 0
			// But in sql row representation, they are NULL and empty string "" respectively, and thus not equal.
			// So we need special logic to handle here: make NULL < ""
			if r1.data[i] == nil && r2.data[i] != nil {
				return true
			}
			if r1.data[i] != nil && r2.data[i] == nil {
				return false
			}
		}
	}
	return false
}

func (rows *byteRows) Swap(i, j int) {
	rows.data[i], rows.data[j] = rows.data[j], rows.data[i]
}

func dumpToByteRows(rows *sql.Rows) (*byteRows, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, errors.Trace(err)
	}

	data := make([]byteRow, 0, 8)
	args := make([]interface{}, len(cols))
	for {
		for rows.Next() {
			tmp := make([][]byte, len(cols))
			for i := 0; i < len(args); i++ {
				args[i] = &tmp[i]
			}
			err := rows.Scan(args...)
			if err != nil {
				return nil, errors.Trace(err)
			}

			data = append(data, byteRow{tmp})
		}
		if !rows.NextResultSet() {
			break
		}
	}
	err = rows.Err()
	if err != nil {
		return nil, errors.Trace(err)
	}

	return &byteRows{cols: cols, data: data}, nil
}

func (t *tester) executeStmt(query string) error {
	log.Debugf("executeStmt: %s", query)
	raw, err := t.curr.conn.QueryContext(context.Background(), query)
	if err != nil {
		return errors.Trace(err)
	}
	defer raw.Close()
	rows, err := dumpToByteRows(raw)
	if err != nil {
		return errors.Trace(err)
	}

	if t.enableResultLog && (len(rows.cols) > 0 || len(rows.data) > 0) {
		if err = t.writeQueryResult(rows); err != nil {
			return errors.Trace(err)
		}
	}

	if t.enableInfo {
		err = t.curr.conn.Raw(func(driverConn any) error {
			rowsAffected := driverConn.(*mysql.MysqlConn).RowsAffected()
			lastMessage := driverConn.(*mysql.MysqlConn).LastMessage()
			t.buf.WriteString(fmt.Sprintf("affected rows: %d\n", rowsAffected))
			t.buf.WriteString(fmt.Sprintf("info: %s\n", lastMessage))
			return nil
		})
		if err != nil {
			log.Errorf("failed to get info: %s", err.Error())
		}
	}

	if t.enableWarning {
		raw, err := t.curr.conn.QueryContext(context.Background(), "show warnings")
		if err != nil {
			return errors.Trace(err)
		}

		rows, err := dumpToByteRows(raw)
		if err != nil {
			return errors.Trace(err)
		}

		if len(rows.data) > 0 {
			sort.Sort(rows)
			return t.writeQueryResult(rows)
		}
	}
	return nil
}

func (t *tester) executeStmtString(query string) (string, error) {
	var result string
	err := t.mdb.QueryRow(query).Scan(&result)
	if err != nil {
		return "", err
	}
	return result, nil
}

func (t *tester) openResult() error {
	if record {
		return nil
	}

	var err error
	t.resultFD, err = os.Open(t.resultFileName())
	return err
}

func (t *tester) flushResult() error {
	if !record {
		return nil
	}
	path := t.resultFileName()
	// Create all directories in the file path
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directories: %v", err)
	}
	return os.WriteFile(path, t.buf.Bytes(), 0644)
}

func (t *tester) testFileName() string {
	// test and result must be in current ./t the same as MySQL
	return fmt.Sprintf("./t/%s.test", t.name)
}

func hasCollationPrefix(name string) bool {
	names := strings.Split(name, "/")
	caseName := names[len(names)-1]
	return strings.HasPrefix(caseName, "collation")
}

func (t *tester) resultFileName() string {
	// test and result must be in current ./r, the same as MySQL
	name := t.name
	if hasCollationPrefix(name) {
		if collationDisable {
			name = name + "_disabled"
		} else {
			name = name + "_enabled"
		}
	}
	return fmt.Sprintf("./r/%s.%s", name, extension)
}

func loadAllTests() ([]string, error) {
	tests := make([]string, 0)
	// tests must be in t folder or subdir in t folder
	err := filepath.Walk("./t/", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(path, ".test") {
			name := strings.TrimPrefix(strings.TrimSuffix(path, ".test"), "t/")
			if !collationDisable || hasCollationPrefix(name) {
				tests = append(tests, name)
			}
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return tests, nil
}

// convertTestsToTestTasks convert all test cases into several testBatches.
// If we have 11 cases and batchSize is 5, then we will have 4 testBatches.
func convertTestsToTestTasks(tests []string) (tTasks []testBatch) {
	batchSize := 30
	total := (len(tests) / batchSize) + 2
	// the extra 1 is for sub_query_more test
	tTasks = make([]testBatch, total+1)
	testIdx := 0
	have_subqmore, have_role := false, false
	for i := 0; i < total; i++ {
		tTasks[i] = make(testBatch, 0, batchSize)
		for j := 0; j <= batchSize && testIdx < len(tests); j++ {
			// skip sub_query_more test, since it consumes the most time
			// we better use a separate goroutine to run it
			// role test has many connection/disconnection operation.
			// we better use a separate goroutine to run it
			switch tests[testIdx] {
			case "sub_query_more":
				have_subqmore = true
			case "role":
				have_role = true
			case "role2":
				have_role = true
			default:
				tTasks[i] = append(tTasks[i], tests[testIdx])
			}
			testIdx++
		}
	}

	if have_subqmore {
		tTasks[total-1] = testBatch{"sub_query_more"}
	}

	if have_role {
		tTasks[total] = testBatch{"role", "role2"}
	}
	return
}

var msgs = make(chan testTask)
var xmlFile *os.File
var testSuite XUnitTestSuite

type testTask struct {
	err  error
	test string
}

type testBatch []string

func (t testBatch) Run() {
	for _, test := range t {
		tr := newTester(test)
		msgs <- testTask{
			test: test,
			err:  tr.Run(),
		}
	}
}

func (t testBatch) String() string {
	return strings.Join([]string(t), ", ")
}

func executeTests(tasks []testBatch) {
	// show and infoschema have to be executed first, since the following
	// tests will create database using their own name.
	// if have_show {
	// 	show := newTester("show")
	// 	msgs <- testTask{
	// 		test: "show",
	// 		err:  show.Run(),
	// 	}
	// }

	// if have_is {
	// 	infoschema := newTester("infoschema")
	// 	msgs <- testTask{
	// 		test: "infoschema",
	// 		err:  infoschema.Run(),
	// 	}
	// }

	for _, t := range tasks {
		t.Run()
	}
}

func consumeError() ([]error, []TestCaseResult) {
	var es []error
	var testDetails []TestCaseResult
	for {
		if t, more := <-msgs; more {
			if t.err != nil {
				e := fmt.Errorf("run test [%s] err: %v", t.test, t.err)
				log.Errorln(e)
				es = append(es, e)
				testDetails = append(testDetails, TestCaseResult{
					Name:     t.test,
					Status:   "failed",
					Duration: 0, // 这里暂时设为0，实际应该从测试中获取
					Error:    t.err.Error(),
				})
			} else {
				log.Infof("run test [%s] ok", t.test)
				testDetails = append(testDetails, TestCaseResult{
					Name:     t.test,
					Status:   "passed",
					Duration: 0, // 这里暂时设为0，实际应该从测试中获取
					Error:    "",
				})
			}
		} else {
			return es, testDetails
		}
	}
}

func main() {
	flag.Parse()
	tests := flag.Args()
	startTime := time.Now()
	if ll := os.Getenv("LOG_LEVEL"); ll != "" {
		logLevel = ll
	}
	if logLevel != "" {
		ll, err := log.ParseLevel(logLevel)
		if err != nil {
			log.Errorf("error parsing log level %s: %v", logLevel, err)
		}
		log.SetLevel(ll)
	}

	if xmlPath != "" {
		_, err := os.Stat(xmlPath)
		if err == nil {
			err = os.Remove(xmlPath)
			if err != nil {
				log.Error("drop previous xunit file fail: ", err)
				os.Exit(1)
			}
		}

		xmlFile, err = os.Create(xmlPath)
		if err != nil {
			log.Error("create xunit file fail:", err)
			os.Exit(1)
		}
		xmlFile, err = os.OpenFile(xmlPath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
		if err != nil {
			log.Error("open xunit file fail:", err)
			os.Exit(1)
		}

		testSuite = XUnitTestSuite{
			Name:       "",
			Tests:      0,
			Failures:   0,
			Properties: make([]XUnitProperty, 0),
			TestCases:  make([]XUnitTestCase, 0),
		}

		defer func() {
			if xmlFile != nil {
				testSuite.Tests = len(tests)
				testSuite.Time = fmt.Sprintf("%fs", time.Since(startTime).Seconds())
				testSuite.Properties = append(testSuite.Properties, XUnitProperty{
					Name:  "go.version",
					Value: goVersion(),
				})
				err := Write(xmlFile, testSuite)
				if err != nil {
					log.Error("Write xunit file fail:", err)
				}
			}
		}()
	}

	// we will run all tests if no tests assigned
	if len(tests) == 0 {
		var err error
		if tests, err = loadAllTests(); err != nil {
			log.Fatalf("load all tests err %v", err)
		}
	}

	if !record {
		log.Infof("running tests: %v", tests)
	} else {
		log.Infof("recording tests: %v", tests)
	}

	if !checkErr {
		log.Warn("--check-error is not set! --error in .test file will simply accept zero or more errors! (i.e. not even check for errors!)")
	}
	go func() {
		executeTests(convertTestsToTestTasks(tests))
		close(msgs)
	}()

	es, testDetails := consumeError()
	endTime := time.Now()

	// 构建测试结果
	testResult := TestResult{
		StartTime:   startTime,
		EndTime:     endTime,
		TotalTests:  len(tests),
		PassedTests: len(tests) - len(es),
		FailedTests: len(es),
		Duration:    endTime.Sub(startTime),
		Errors:      es,
		TestDetails: testDetails,
	}

	// 发送邮件通知（如果启用了邮件功能）
	if emailEnable {
		emailConfig := parseEmailConfig()
		if err := SendEmailNotification(emailConfig, testResult); err != nil {
			log.Errorf("发送邮件通知失败: %v", err)
		}
	}

	println()
	if len(es) != 0 {
		log.Errorf("%d tests failed\n", len(es))
		for _, item := range es {
			log.Errorln(item)
		}
		// Can't delete this statement.
		os.Exit(1)
	} else {
		println("Great, All tests passed")
	}
}

//type.go
// Copyright 2020 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"strings"
)

var commandMap = map[string]int{
	"connection":                 Q_CONNECTION,
	"query":                      Q_QUERY,
	"connect":                    Q_CONNECT,
	"sleep":                      Q_SLEEP,
	"real_sleep":                 Q_REAL_SLEEP,
	"inc":                        Q_INC,
	"dec":                        Q_DEC,
	"source":                     Q_SOURCE,
	"disconnect":                 Q_DISCONNECT,
	"let":                        Q_LET,
	"echo":                       Q_ECHO,
	"while":                      Q_WHILE,
	"end":                        Q_END_BLOCK,
	"system":                     Q_SYSTEM,
	"result":                     Q_RESULT,
	"require":                    Q_REQUIRE,
	"save_master_pos":            Q_SAVE_MASTER_POS,
	"sync_with_master":           Q_SYNC_WITH_MASTER,
	"sync_slave_with_master":     Q_SYNC_SLAVE_WITH_MASTER,
	"error":                      Q_ERROR,
	"send":                       Q_SEND,
	"reap":                       Q_REAP,
	"dirty_close":                Q_DIRTY_CLOSE,
	"replace_result":             Q_REPLACE,
	"replace_column":             Q_REPLACE_COLUMN,
	"ping":                       Q_PING,
	"eval":                       Q_EVAL,
	"eval_result":                Q_EVAL_RESULT,
	"enable_query_log":           Q_ENABLE_QUERY_LOG,
	"disable_query_log":          Q_DISABLE_QUERY_LOG,
	"enable_result_log":          Q_ENABLE_RESULT_LOG,
	"disable_result_log":         Q_DISABLE_RESULT_LOG,
	"enable_connect_log":         Q_ENABLE_CONNECT_LOG,
	"disable_connect_log":        Q_DISABLE_CONNECT_LOG,
	"wait_for_slave_to_stop":     Q_WAIT_FOR_SLAVE_TO_STOP,
	"enable_warnings":            Q_ENABLE_WARNINGS,
	"disable_warnings":           Q_DISABLE_WARNINGS,
	"enable_info":                Q_ENABLE_INFO,
	"disable_info":               Q_DISABLE_INFO,
	"enable_session_track_info":  Q_ENABLE_SESSION_TRACK_INFO,
	"disable_session_track_info": Q_DISABLE_SESSION_TRACK_INFO,
	"enable_metadata":            Q_ENABLE_METADATA,
	"disable_metadata":           Q_DISABLE_METADATA,
	"exec":                       Q_EXEC,
	"execw":                      Q_EXECW,
	"delimiter":                  Q_DELIMITER,
	"disable_abort_on_error":     Q_DISABLE_ABORT_ON_ERROR,
	"enable_abort_on_error":      Q_ENABLE_ABORT_ON_ERROR,
	"vertical_results":           Q_DISPLAY_VERTICAL_RESULTS,
	"horizontal_results":         Q_DISPLAY_HORIZONTAL_RESULTS,
	"query_vertical":             Q_QUERY_VERTICAL,
	"query_horizontal":           Q_QUERY_HORIZONTAL,
	"sorted_result":              Q_SORTED_RESULT,
	"lowercase_result":           Q_LOWERCASE,
	"start_timer":                Q_START_TIMER,
	"end_timer":                  Q_END_TIMER,
	"character_set":              Q_CHARACTER_SET,
	"disable_ps_protocol":        Q_DISABLE_PS_PROTOCOL,
	"enable_ps_protocol":         Q_ENABLE_PS_PROTOCOL,
	"disable_reconnect":          Q_DISABLE_RECONNECT,
	"enable_reconnect":           Q_ENABLE_RECONNECT,
	"if":                         Q_IF,
	"disable_parsing":            Q_DISABLE_PARSING,
	"enable_parsing":             Q_ENABLE_PARSING,
	"replace_regex":              Q_REPLACE_REGEX,
	"replace_numeric_round":      Q_REPLACE_NUMERIC_ROUND,
	"remove_file":                Q_REMOVE_FILE,
	"file_exists":                Q_FILE_EXIST,
	"write_file":                 Q_WRITE_FILE,
	"copy_file":                  Q_COPY_FILE,
	"perl":                       Q_PERL,
	"die":                        Q_DIE,
	"exit":                       Q_EXIT,
	"skip":                       Q_SKIP,
	"chmod":                      Q_CHMOD_FILE,
	"append_file":                Q_APPEND_FILE,
	"cat_file":                   Q_CAT_FILE,
	"diff_files":                 Q_DIFF_FILES,
	"send_quit":                  Q_SEND_QUIT,
	"change_user":                Q_CHANGE_USER,
	"mkdir":                      Q_MKDIR,
	"rmdir":                      Q_RMDIR,
	"list_files":                 Q_LIST_FILES,
	"list_files_write_file":      Q_LIST_FILES_WRITE_FILE,
	"list_files_append_file":     Q_LIST_FILES_APPEND_FILE,
	"send_shutdown":              Q_SEND_SHUTDOWN,
	"shutdown_server":            Q_SHUTDOWN_SERVER,
	"result_format":              Q_RESULT_FORMAT_VERSION,
	"move_file":                  Q_MOVE_FILE,
	"remove_files_wildcard":      Q_REMOVE_FILES_WILDCARD,
	"send_eval":                  Q_SEND_EVAL,
	"output":                     Q_OUTPUT,
	"reset_connection":           Q_RESET_CONNECTION,
	"single_query":               Q_SINGLE_QUERY,
	"begin_concurrent":           Q_BEGIN_CONCURRENT,
	"end_concurrent":             Q_END_CONCURRENT,
}

func findType(cmdName string) int {
	key := strings.ToLower(cmdName)
	if v, ok := commandMap[key]; ok {
		return v
	}

	return -1
}


//util.go
// Copyright 2020 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"database/sql"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/pingcap/errors"
	log "github.com/sirupsen/logrus"
)

// OpenDBWithRetry opens a database specified by its database driver name and a
// driver-specific data source name. And it will do some retries if the connection fails.
func OpenDBWithRetry(driverName, dataSourceName string, retryCount int) (mdb *sql.DB, err error) {
	startTime := time.Now()
	sleepTime := time.Millisecond * 500
	// Parse DSN to extract connection info for better error messages
	var host, port, dbname string
	if parts := strings.Split(dataSourceName, "@tcp("); len(parts) > 1 {
		if hostParts := strings.Split(parts[1], ")"); len(hostParts) > 0 {
			hostPort := strings.Split(hostParts[0], ":")
			if len(hostPort) >= 2 {
				host = hostPort[0]
				port = hostPort[1]
			}
		}
	}
	if parts := strings.Split(dataSourceName, ")/"); len(parts) > 1 {
		dbParts := strings.Split(parts[1], "?")
		if len(dbParts) > 0 {
			dbname = dbParts[0]
		}
	}

	// The max retry interval is 60 s.
	for i := 0; i < retryCount; i++ {
		mdb, err = sql.Open(driverName, dataSourceName)
		if err != nil {
			log.Warnf("第 %d 次尝试连接数据库失败，还剩 %d 次重试，错误：%v", i+1, retryCount-i-1, err)
			time.Sleep(sleepTime)
			continue
		}
		err = mdb.Ping()
		if err == nil {
			break
		}
		log.Warnf("第 %d 次尝试ping数据库失败，还剩 %d 次重试，错误：%v", i+1, retryCount-i-1, err)
		mdb.Close()
		time.Sleep(sleepTime)
	}
	if err != nil {
		// Provide user-friendly error message
		var friendlyMsg strings.Builder
		friendlyMsg.WriteString("数据库连接失败，请检查以下配置：\n")
		if host != "" && port != "" {
			friendlyMsg.WriteString(fmt.Sprintf("  - 主机地址: %s\n", host))
			friendlyMsg.WriteString(fmt.Sprintf("  - 端口: %s\n", port))
		}
		if dbname != "" {
			friendlyMsg.WriteString(fmt.Sprintf("  - 数据库名: %s\n", dbname))
		}
		friendlyMsg.WriteString("  - 请确认数据库服务是否启动\n")
		friendlyMsg.WriteString("  - 请确认网络连接是否正常\n")
		friendlyMsg.WriteString("  - 请确认用户名和密码是否正确\n")
		friendlyMsg.WriteString("  - 请确认防火墙设置是否阻止连接\n")
		friendlyMsg.WriteString(fmt.Sprintf("\n总耗时: %v，重试次数: %d\n", time.Since(startTime), retryCount))
		friendlyMsg.WriteString(fmt.Sprintf("底层错误: %v", err))

		log.Errorf(friendlyMsg.String())
		return nil, errors.Trace(errors.Errorf("数据库连接失败: %v", err))
	}

	return
}

func processEscapes(str string) string {
	escapeMap := map[string]string{
		`\n`: "\n",
		`\t`: "\t",
		`\r`: "\r",
		`\/`: "/",
		`\\`: "\\", // better be the last one
	}

	for escape, replacement := range escapeMap {
		str = strings.ReplaceAll(str, escape, replacement)
	}

	return str
}

func ParseReplaceRegex(originalString string) ([]*ReplaceRegex, error) {
	var begin, middle, end, cnt int
	ret := make([]*ReplaceRegex, 0)
	for i, c := range originalString {
		if c != '/' {
			continue
		}
		if i != 0 && originalString[i-1] == '\\' {
			continue
		}
		cnt++
		switch cnt % 3 {
		// The first '/'
		case 1:
			begin = i
		// The second '/'
		case 2:
			middle = i
		// The last '/', we could compile regex and process replace string
		case 0:
			end = i
			reg, err := regexp.Compile(originalString[begin+1 : middle])
			if err != nil {
				return nil, err
			}
			ret = append(ret, &ReplaceRegex{
				regex:   reg,
				replace: processEscapes(originalString[middle+1 : end]),
			})
		}
	}
	if cnt%3 != 0 {
		return nil, errors.Errorf("Could not parse regex in --replace_regex: sql:%v", originalString)
	}
	return ret, nil
}

//query.go
// Copyright 2020 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"strings"

	"github.com/pingcap/errors"
	log "github.com/sirupsen/logrus"
)

var ErrInvalidCommand = errors.New("Found line beginning with -- that didn't contain a valid mysqltest command, check your syntax or use # if you intended to write comment")

// Different query command type
const (
	Q_CONNECTION = iota + 1
	Q_QUERY
	Q_CONNECT
	Q_SLEEP
	Q_REAL_SLEEP
	Q_INC
	Q_DEC
	Q_SOURCE
	Q_DISCONNECT
	Q_LET
	Q_ECHO
	Q_WHILE
	Q_END_BLOCK
	Q_SYSTEM
	Q_RESULT
	Q_REQUIRE
	Q_SAVE_MASTER_POS
	Q_SYNC_WITH_MASTER
	Q_SYNC_SLAVE_WITH_MASTER
	Q_ERROR
	Q_SEND
	Q_REAP
	Q_DIRTY_CLOSE
	Q_REPLACE
	Q_REPLACE_COLUMN
	Q_PING
	Q_EVAL
	Q_EVAL_RESULT
	Q_ENABLE_QUERY_LOG
	Q_DISABLE_QUERY_LOG
	Q_ENABLE_RESULT_LOG
	Q_DISABLE_RESULT_LOG
	Q_ENABLE_CONNECT_LOG
	Q_DISABLE_CONNECT_LOG
	Q_WAIT_FOR_SLAVE_TO_STOP
	Q_ENABLE_WARNINGS
	Q_DISABLE_WARNINGS
	Q_ENABLE_INFO
	Q_DISABLE_INFO
	Q_ENABLE_SESSION_TRACK_INFO
	Q_DISABLE_SESSION_TRACK_INFO
	Q_ENABLE_METADATA
	Q_DISABLE_METADATA
	Q_EXEC
	Q_EXECW
	Q_DELIMITER
	Q_DISABLE_ABORT_ON_ERROR
	Q_ENABLE_ABORT_ON_ERROR
	Q_DISPLAY_VERTICAL_RESULTS
	Q_DISPLAY_HORIZONTAL_RESULTS
	Q_QUERY_VERTICAL
	Q_QUERY_HORIZONTAL
	Q_SORTED_RESULT
	Q_LOWERCASE
	Q_START_TIMER
	Q_END_TIMER
	Q_CHARACTER_SET
	Q_DISABLE_PS_PROTOCOL
	Q_ENABLE_PS_PROTOCOL
	Q_DISABLE_RECONNECT
	Q_ENABLE_RECONNECT
	Q_IF
	Q_DISABLE_PARSING
	Q_ENABLE_PARSING
	Q_REPLACE_REGEX
	Q_REPLACE_NUMERIC_ROUND
	Q_REMOVE_FILE
	Q_FILE_EXIST
	Q_WRITE_FILE
	Q_COPY_FILE
	Q_PERL
	Q_DIE
	Q_EXIT
	Q_SKIP
	Q_CHMOD_FILE
	Q_APPEND_FILE
	Q_CAT_FILE
	Q_DIFF_FILES
	Q_SEND_QUIT
	Q_CHANGE_USER
	Q_MKDIR
	Q_RMDIR
	Q_LIST_FILES
	Q_LIST_FILES_WRITE_FILE
	Q_LIST_FILES_APPEND_FILE
	Q_SEND_SHUTDOWN
	Q_SHUTDOWN_SERVER
	Q_RESULT_FORMAT_VERSION
	Q_MOVE_FILE
	Q_REMOVE_FILES_WILDCARD
	Q_SEND_EVAL
	Q_OUTPUT /* redirect output to a file */
	Q_RESET_CONNECTION
	Q_SINGLE_QUERY
	Q_BEGIN_CONCURRENT
	Q_END_CONCURRENT
	Q_UNKNOWN /* Unknown command.   */
	Q_COMMENT /* Comments, ignored. */
	Q_COMMENT_WITH_COMMAND
	Q_EMPTY_LINE
)

// ParseQuery parses an array of string into an array of query object.
// Note: a query statement may reside in several lines.
func ParseQuery(rs query) (*query, error) {
	realS := rs.Query
	s := rs.Query
	q := query{delimiter: rs.delimiter, Line: rs.Line}
	q.tp = Q_UNKNOWN
	// a valid query's length should be at least 3.
	if len(s) < 3 {
		return nil, nil
	}
	// we will skip #comment and line with zero characters here
	if s[0] == '#' {
		q.tp = Q_COMMENT
	} else if s[0:2] == "--" {
		q.tp = Q_COMMENT_WITH_COMMAND
		if s[2] == ' ' {
			s = s[3:]
		} else {
			s = s[2:]
		}
	} else if s[0] == '\n' {
		q.tp = Q_EMPTY_LINE
	}

	if q.tp != Q_COMMENT {
		// Calculate first word length(the command), terminated
		// by 'space' , '(' and delimiter
		var i int
		for i = 0; i < len(s); i++ {
			if s[i] == '(' || s[i] == ' ' || s[i] == '\n' {
				break
			}
			if i+len(rs.delimiter) <= len(s) && s[i:i+len(rs.delimiter)] == rs.delimiter {
				break
			}
		}
		if i > 0 {
			q.firstWord = s[:i]
		}
		s = s[i:]

		q.Query = s
		if q.tp == Q_UNKNOWN || q.tp == Q_COMMENT_WITH_COMMAND {
			if err := q.getQueryType(realS); err != nil {
				return nil, err
			}
		}
	}

	return &q, nil
}

// for a single query, it has some prefix. Prefix mapps to a query type.
// e.g query_vertical maps to Q_QUERY_VERTICAL
func (q *query) getQueryType(qu string) error {
	tp := findType(q.firstWord)
	if tp > 0 {
		if tp == Q_ECHO || tp == Q_SORTED_RESULT {
			q.Query = strings.TrimSpace(q.Query)
		}
		q.tp = tp
	} else {
		// No mysqltest command matched
		if q.tp != Q_COMMENT_WITH_COMMAND {
			// A query that will sent to tidb
			q.Query = qu
			q.tp = Q_QUERY
		} else {
			log.WithFields(log.Fields{"line": q.Line, "command": q.firstWord, "arguments": q.Query}).Error("invalid command")
			return ErrInvalidCommand
		}
	}
	return nil
}

//xml.go
// Copyright 2020 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"encoding/xml"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"
)

// XUnitTestSuites is a set of mysqltest suite.
type XUnitTestSuites struct {
	XMLName xml.Name `xml:"testsuites"`
	Suites  []XUnitTestSuite
}

// XUnitTestSuite is a single mysqltest suite which may contain many
// testcases in a directory
type XUnitTestSuite struct {
	XMLName    xml.Name        `xml:"testsuite"`
	Tests      int             `xml:"tests,attr"`
	Failures   int             `xml:"failures,attr"`
	Name       string          `xml:"name,attr"`
	Time       string          `xml:"time,attr"`
	Timestamp  string          `xml:"timestamp,attr"`
	Hostname   string          `xml:"hostname,attr"`
	Properties []XUnitProperty `xml:"properties>property,omitempty"`
	TestCases  []XUnitTestCase
}

// XUnitTestCase is a single test case with its result.
type XUnitTestCase struct {
	XMLName     xml.Name          `xml:"testcase"`
	Classname   string            `xml:"classname,attr"`
	Name        string            `xml:"name,attr"`
	Time        string            `xml:"time,attr"`
	QueryCount  int               `xml:"query-count,attr"`
	Status      string            `xml:"status,attr,omitempty"`
	Failure     *XUnitFailure     `xml:"failure,omitempty"`
	Properties  []XUnitProperty   `xml:"properties>property,omitempty"`
	Attachments []XUnitAttachment `xml:"attachments>attachment,omitempty"`
}

// XUnitFailure represents a test failure
type XUnitFailure struct {
	Message string `xml:"message,attr"`
	Type    string `xml:"type,attr"`
	Content string `xml:",chardata"`
}

// XUnitAttachment represents a file attachment for a test case
type XUnitAttachment struct {
	Name   string `xml:"name,attr"`
	Source string `xml:"source,attr"`
	Type   string `xml:"type,attr"`
}

// XUnitProperty represents a key/value pair used to define properties.
type XUnitProperty struct {
	Name  string `xml:"name,attr"`
	Value string `xml:"value,attr"`
}

func Write(out io.Writer, testSuite XUnitTestSuite) error {
	// 添加Allure所需的时间戳和主机名
	hostname, _ := os.Hostname()
	if hostname == "" {
		hostname = "localhost"
	}
	testSuite.Timestamp = time.Now().Format(time.RFC3339)
	testSuite.Hostname = hostname
	
	// 为测试用例添加状态、属性和处理失败信息
	now := time.Now().Format(time.RFC3339)
	for i := range testSuite.TestCases {
		// 将原来的字符串失败信息转换为结构化失败对象
		if testSuite.TestCases[i].Failure == nil {
			if testSuite.TestCases[i].Status == "" {
				testSuite.TestCases[i].Status = "passed"
			}
		} else {
			testSuite.TestCases[i].Status = "failed"
		}
		
		// 添加测试用例的属性信息
		testDuration := 0
		if testSuite.TestCases[i].Time != "" {
			dur, err := time.ParseDuration(strings.TrimSuffix(testSuite.TestCases[i].Time, "s") + "s")
			if err == nil {
				testDuration = int(dur.Milliseconds())
			}
		}
		
		testSuite.TestCases[i].Properties = []XUnitProperty{
			{Name: "test_framework", Value: "mysql-tester"},
			{Name: "test_started_at", Value: now},
			{Name: "test_ended_at", Value: now},
			{Name: "test_duration_ms", Value: fmt.Sprintf("%d", testDuration)},
		}
	}
	
	testSuites := XUnitTestSuites{
		Suites: make([]XUnitTestSuite, 0),
	}
	testSuites.Suites = append(testSuites.Suites, testSuite)
	_, err := out.Write([]byte(xml.Header))
	if err != nil {
		log.Error("write xunit file fail:", err)
		return err
	}
	doc, err := xml.MarshalIndent(testSuites, "", "\t")
	if err != nil {
		return err
	}
	_, err = out.Write(doc)
	return err
}

// goVersion returns the version as reported by the go binary in PATH. This
// version will not be the same as runtime.Version, which is always the version
// of go used to build the gotestsum binary.
//
// To skip the os/exec call set the GOVERSION environment variable to the
// desired value.
func goVersion() string {
	if version, ok := os.LookupEnv("GOVERSION"); ok {
		return version
	}
	cmd := exec.Command("go", "version")
	out, err := cmd.Output()
	if err != nil {
		return "unknown"
	}
	return strings.TrimPrefix(strings.TrimSpace(string(out)), "go version ")
}
